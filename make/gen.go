/*
Copyright 2025 The goARRG Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vkm

/*
	#include "../include/vkm/vkm_config.h"
*/
import "C"

import (
	"bufio"
	"fmt"
	"io/fs"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strconv"
	"strings"

	"goarrg.com/lib/vkm/vkspec"
	"goarrg.com/toolchain/golang"
)

const genString = "// go run ./cmd/make gen\n// Code generated by the command above; DO NOT EDIT.\n\n"

func Gen() {
	vkapi := uint64(C.VKM_VK_MIN_API)
	installGeneratorDeps()

	rootDir := golang.CallersModule().Dir
	srcDir := filepath.Join(rootDir, "src")
	genFN(srcDir)

	data := vkspec.Parse()

	buildDir := filepath.Join(rootDir, "include", "vkm", "inc")
	genNonShipables(srcDir, buildDir, data, vkapi)
}

func genNonShipables(srcDir, buildDir string, data vkspec.Data, vkapi uint64) {
	err := os.MkdirAll(buildDir, 0o755)
	if err != nil {
		panic(err)
	}
	genDispatchTable(srcDir, buildDir, data, vkapi)
	genStructReflection(srcDir, buildDir, data, vkapi)
	genExtensionReflection(srcDir, buildDir, data, vkapi)
	genConstReflection(srcDir, buildDir, data)
}

func genFN(srcDir string) {
	ifns := make(map[string]struct{})
	dfns := make(map[string]struct{})

	filepath.WalkDir(srcDir, func(path string, entry fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if entry.Type().IsRegular() {
			if strings.HasSuffix(entry.Name(), ".h") || strings.HasSuffix(entry.Name(), ".hpp") ||
				strings.HasSuffix(entry.Name(), ".c") || strings.HasSuffix(entry.Name(), ".cpp") {
				{
					f, err := os.Open(path)
					if err != nil {
						panic(err)
					}

					defer f.Close()
					scanner := bufio.NewScanner(f)

					for scanner.Scan() {
						s := strings.TrimSpace(scanner.Text())

						if i := strings.Index(s, "VK_PROC(vk"); i >= 0 && !strings.HasPrefix(s, "#") && !strings.HasPrefix(s, "//") {
							fn := s[i : strings.IndexRune(s[i:], ')')+i+1]
							ifns[fn] = struct{}{}
							continue
						}
						if i := strings.Index(s, "VK_DEBUG_PROC(vk"); i >= 0 && !strings.HasPrefix(s, "#") && !strings.HasPrefix(s, "//") {
							fn := s[i : strings.IndexRune(s[i:], ')')+i+1]
							ifns[fn] = struct{}{}
							continue
						}

						if i := strings.Index(s, "VK_PROC_DEVICE("); i >= 0 && !strings.HasPrefix(s, "#") && !strings.HasPrefix(s, "//") {
							s = s[i : strings.IndexRune(s[i:], ')')+i+1]
							i = strings.LastIndexAny(s, ", ")
							if i <= 0 {
								continue
							}
							fn := "VK_PROC_DEVICE(" + s[i+1:]
							dfns[fn] = struct{}{}
							continue
						}
						if i := strings.Index(s, "VK_DEBUG_PROC_DEVICE("); i >= 0 && !strings.HasPrefix(s, "#") && !strings.HasPrefix(s, "//") {
							s = s[i : strings.IndexRune(s[i:], ')')+i+1]
							i = strings.LastIndexAny(s, ", ")
							if i <= 0 {
								continue
							}
							fn := "VK_DEBUG_PROC_DEVICE(" + s[i+1:]
							dfns[fn] = struct{}{}
							continue
						}
					}
				}
			}
		}
		return nil
	})

	writeFile := func(fns map[string]struct{}, outFile string) {
		out, err := os.Create(outFile)
		if err != nil {
			panic(err)
		}

		defer out.Close()
		w := bufio.NewWriter(out)

		if _, err := w.WriteString(genString); err != nil {
			panic(err)
		}

		sortedfns := make([]string, 0, len(fns))

		for k := range fns {
			i := sort.SearchStrings(sortedfns, k)
			sortedfns = append(sortedfns[:i+1], sortedfns[i:]...)
			sortedfns[i] = k
		}
		for _, fn := range sortedfns {
			if _, err := w.WriteString(fn + "\n"); err != nil {
				panic(err)
			}
		}

		if err := w.Flush(); err != nil {
			panic(err)
		}
	}

	writeFile(ifns, filepath.Join(srcDir, "vkfn.inc"))
	writeFile(dfns, filepath.Join(srcDir, "device", "device_vkfn.inc"))
}

func genDispatchTable(srcDir, buildDir string, data vkspec.Data, vkapi uint64) {
	fOutInstance, err := os.Create(filepath.Join(buildDir, "vkfn_dispatch_instance.inc"))
	if err != nil {
		panic(err)
	}
	fOutDevice, err := os.Create(filepath.Join(buildDir, "vkfn_dispatch_device.inc"))
	if err != nil {
		panic(err)
	}

	defer fOutInstance.Close()
	defer fOutDevice.Close()
	fmt.Fprintf(fOutInstance, genString)
	fmt.Fprintf(fOutDevice, genString)

	cmds := slices.Sorted(maps.Keys(data.Commands))
	blacklist := map[string]bool{
		"vkCreateInstance":      true,
		"vkGetInstanceProcAddr": true,
		"vkGetDeviceProcAddr":   true,
	}
	fmt.Fprintf(fOutInstance, "VKM_VKFN(vkGetInstanceProcAddr)\n")
	fmt.Fprintf(fOutInstance, "VKM_VKFN(vkGetDeviceProcAddr)\n")

	for _, e := range data.Extensions {
		promoted := e.Promoted
		for promoted != "" && !strings.HasPrefix(promoted, "VK_VERSION_") {
			promoted = data.Extensions[promoted].Promoted
		}
		if e.Valid && e.Platform == "" && !e.Provisional && promoted == "" {
			continue
		}
		if vkVersion, ok := strings.CutPrefix(promoted, "VK_VERSION_"); ok {
			versionPair := strings.Split(vkVersion, "_")
			major, err := strconv.ParseUint(versionPair[0], 10, 0)
			if err != nil {
				panic(err)
			}
			minor, err := strconv.ParseUint(versionPair[1], 10, 0)
			if err != nil {
				panic(err)
			}
			if vkapi < (major<<22)|(minor<<12) {
				continue
			}
		}
		for _, cmd := range e.Commands {
			blacklist[cmd] = true
		}
	}

	for _, cmd := range cmds {
		if blacklist[cmd] {
			continue
		}
		info := data.Commands[cmd]
		if h, isHandle := data.Handles[info.Params[0].TypeName]; isHandle {
			dispatcher := h.Name
			if h.Name != "VkInstance" && h.Name != "VkDevice" {
			parentLoop:
				for h.Parent != "" {
					switch h.Parent {
					case "VkDevice", "VkInstance":
						dispatcher = h.Parent
						break parentLoop
					}
					h = data.Handles[h.Parent]
				}
			}
			switch dispatcher {
			case "VkInstance":
				fmt.Fprintf(fOutInstance, "VKM_VKFN(%s)\n", cmd)
			case "VkDevice":
				fmt.Fprintf(fOutDevice, "VKM_VKFN(%s)\n", cmd)
			default:
				panic(fmt.Sprintln("Unhandled: ", cmd))
			}
		} else {
			fmt.Fprintf(fOutInstance, "VKM_VKFN(%s)\n", cmd)
		}
	}
}

func genStructReflection(srcDir, buildDir string, data vkspec.Data, vkapi uint64) {
	typeNames := slices.Sorted(maps.Keys(data.Types))

	sTypes := map[string]string{}
	blacklist := map[string]bool{}
	structExtensionMap := map[string]vkspec.Extension{}
	type structDepends struct {
		name  string
		depth int
	}
	structDependsMap := map[string][]structDepends{}

	// map struct name to stype
	for _, t := range data.Types["VkStructureType"].Declaration {
		fields := strings.Fields(t)
		structType := "VK" + strings.ReplaceAll(strings.TrimPrefix(fields[0], "VK_STRUCTURE_TYPE"), "_", "")
		if structType == "VKPHYSICALDEVICEFEATURES2" {
			continue
		}
		sTypes[structType] = fields[0]
	}

	// map extensions and their dependencies and blacklist duplicated promoted structs
	{
		mapDepends := func(s string, e vkspec.Extension) {
			promoted := e.Promoted
			promotionDepth := 0
			for promoted != "" && !strings.HasPrefix(promoted, "VK_VERSION_") {
				promoted = data.Extensions[promoted].Promoted
				promotionDepth++
			}

			structDependsMap[s] = append(structDependsMap[s], structDepends{
				name:  e.Name,
				depth: promotionDepth,
			})
		}
		mapExtension := func(e vkspec.Extension) {
			for _, s := range e.Types {
				structExtensionMap[s] = e
				mapDepends(s, e)

				kind, ok := sTypes[strings.ToUpper(s)]
				if !ok {
					continue
				}
				kind = kind[strings.LastIndex(kind, "_")+1:]
				blacklist[strings.TrimSuffix(s, kind)] = true
			}
		}
		for _, k := range slices.Sorted(maps.Keys(data.Extensions)) {
			e := data.Extensions[k]
			promoted := e.Promoted
			for promoted != "" && data.Extensions[promoted].Promoted != "" && !strings.HasPrefix(promoted, "VK_VERSION_") {
				promoted = data.Extensions[promoted].Promoted
			}
			if e.Valid && e.Platform == "" && !e.Provisional && promoted == "" {
				mapExtension(e)
				continue
			}
			isCoreAtMin := false
			if vkVersion, ok := strings.CutPrefix(promoted, "VK_VERSION_"); e.Valid && !e.Provisional && ok {
				versionPair := strings.Split(vkVersion, "_")
				major, err := strconv.ParseUint(versionPair[0], 10, 0)
				if err != nil {
					panic(err)
				}
				minor, err := strconv.ParseUint(versionPair[1], 10, 0)
				if err != nil {
					panic(err)
				}
				if (e.Promoted == promoted) && (vkapi < (major<<22)|(minor<<12)) {
					mapExtension(e)
					continue
				} else {
					isCoreAtMin = true
				}
			}

			for _, s := range e.Types {
				isAliased := data.Types[s].Alias != ""
				if e.Valid && !e.Provisional && !isAliased && !isCoreAtMin {
					mapExtension(e)
					continue
				}
				blacklist[s] = true
				for _, s := range data.Extensions[promoted].Types {
					mapDepends(s, e)
				}
			}
		}
	}

	for k := range structDependsMap {
		slices.SortFunc(structDependsMap[k], func(a, b structDepends) int {
			return a.depth - b.depth
		})
	}

	// genFeatureReflection
	{
		fOut, err := os.Create(filepath.Join(buildDir, "reflect_struct_deviceFeatureStruct.inc"))
		if err != nil {
			panic(err)
		}

		defer fOut.Close()
		fmt.Fprintf(fOut, genString)

		fmt.Fprintf(fOut, "// NOLINTBEGIN\n")
		defer fmt.Fprintf(fOut, "// NOLINTEND\n")

		structs := []string{}
		{
			fmt.Fprintf(fOut, "namespace internal {\n")
			writeField := func(k string, field []string) {
				t := field[0]
				switch t {
				case "VkStructureType":
					t = "vkStructureType"
				case "void*":
					t = "voidPtr"
				case "VkBool32":
					t = "vkBool32"
				}
				fmt.Fprintf(fOut, "\tstructField{type::%[2]s, offsetof(%[1]s, %[3]s), \"%[3]s\"},\n", k, t, field[1])
			}

			{
				structFields := data.Types["VkPhysicalDeviceFeatures"]
				fmt.Fprintf(fOut, "static constexpr ::vkm::vk::reflect::internal::structTypeImpl<0, %d> typeVkPhysicalDeviceFeatures {\n", len(structFields.Declaration))
				fmt.Fprintf(fOut, "\t\"VkPhysicalDeviceFeatures\", sizeof(VkPhysicalDeviceFeatures),\n")
				for _, line := range structFields.Declaration {
					field := strings.Fields(line)
					writeField("VkPhysicalDeviceFeatures", field)
				}
				fmt.Fprintf(fOut, "};\n")
			}

			// get struct information
			for _, k := range typeNames {
				isPhysicalDevice := strings.HasPrefix(k, "VkPhysicalDevice")
				isFeatures := strings.Contains(k, "Features")
				if !isPhysicalDevice || !isFeatures {
					continue
				}
				if stype, ok := sTypes[strings.ToUpper(k)]; ok {
					if blacklist[k] {
						// fmt.Println("BlackListed:", k)
						continue
					}
					if len(structExtensionMap[k].Name) == 0 {
						if len(k) != len("VkPhysicalDeviceVulkan11Features") ||
							(!strings.HasPrefix(k, "VkPhysicalDeviceVulkan1") || !strings.HasSuffix(k, "Features")) {
							// fmt.Println("Not Ext:", k)
							continue
						}
						structDependsMap[k] = []structDepends{
							{name: "VK_VERSION_1_" + strings.TrimSuffix(strings.TrimPrefix(k, "VkPhysicalDeviceVulkan1"), "Features")},
						}
					}
					if len(structDependsMap[k]) > 1 {
						// fmt.Println("Promoted:", k)
					}

					structs = append(structs, k)
					structFields := data.Types[k]
					fmt.Fprintf(fOut, "static constexpr ::vkm::vk::reflect::internal::structChainTypeImpl<%d, %d> type%s {\n", len(structDependsMap[k]), len(structFields.Declaration), k)
					fmt.Fprintf(fOut, "\t%[1]s, \"%[2]s\", sizeof(%[2]s),\n", stype, k)
					if len(structDependsMap[k]) > 0 {
						fmt.Fprintf(fOut, "\t{\n")
						for _, d := range structDependsMap[k] {
							fmt.Fprintf(fOut, "\t\t&%q[0],\n", d.name)
						}
						fmt.Fprintf(fOut, "\t},\n")
						fmt.Fprintf(fOut, "\t{\n")
						for _, line := range structFields.Declaration {
							fmt.Fprintf(fOut, "\t")
							field := strings.Fields(line)
							writeField(k, field)
						}
						fmt.Fprintf(fOut, "\t},\n")
					} else {
						for _, line := range structFields.Declaration {
							field := strings.Fields(line)
							writeField(k, field)
						}
					}

					fmt.Fprintf(fOut, "};\n")
				}
			}
			fmt.Fprintf(fOut, "} // namespace vkm::vk::reflect::device::featureStruct::internal\n")
		}
		slices.Sort(structs)

		// TypeOf

		fmt.Fprintf(fOut, "[[nodiscard]] static inline const structType* typeOf(VkStructureType sType) noexcept {\n")
		fmt.Fprintf(fOut, "\tswitch(sType){\n")

		for _, t := range structs {
			if sType, ok := sTypes[strings.ToUpper(t)]; ok {
				fmt.Fprintf(fOut, "\t\tcase %s:\n", sType)
				fmt.Fprintf(fOut, "\t\t\treturn &internal::type%s;\n", t)
			}
		}

		fmt.Fprintf(fOut, "\t};\n")
		fmt.Fprintf(fOut, "\treturn nullptr;\n")
		fmt.Fprintf(fOut, "}\n")

		fmt.Fprintf(fOut, "[[nodiscard]] static inline const structType* typeOf(const vkStructureChain* ptr) noexcept {\n")
		fmt.Fprintf(fOut, "\treturn typeOf(ptr->sType);\n")
		fmt.Fprintf(fOut, "}\n")

		fmt.Fprintf(fOut, "[[nodiscard]] static inline const structType* typeOf(const VkPhysicalDeviceFeatures*) noexcept {\n")
		fmt.Fprintf(fOut, "\treturn &internal::typeVkPhysicalDeviceFeatures;\n")
		fmt.Fprintf(fOut, "}\n")

		// ValueOf

		fmt.Fprintf(fOut, "[[nodiscard]] static inline vkm::std::smartPtr<structValue> valueOf(vkStructureChain* ptr) noexcept {\n")
		fmt.Fprintf(fOut, "\tswitch(ptr->sType){\n")

		for _, t := range structs {
			if sType, ok := sTypes[strings.ToUpper(t)]; ok {
				fmt.Fprintf(fOut, "\t\tcase %s:\n", sType)
				fmt.Fprintf(fOut, "\t\t\treturn new (::std::nothrow) ::vkm::vk::reflect::internal::structValueImpl<internal::type%[1]s.numFields()>{&internal::type%[1]s, ptr};\n", t)
			}
		}

		fmt.Fprintf(fOut, "\t};\n")
		fmt.Fprintf(fOut, "\treturn nullptr;\n")
		fmt.Fprintf(fOut, "}\n")

		fmt.Fprintf(fOut, "[[nodiscard]] static inline vkm::std::smartPtr<structValue> valueOf(VkPhysicalDeviceFeatures* ptr) noexcept {\n")
		fmt.Fprintf(fOut, "\treturn new (::std::nothrow) ::vkm::vk::reflect::internal::structValueImpl<internal::typeVkPhysicalDeviceFeatures.numFields()>{&internal::typeVkPhysicalDeviceFeatures, ptr};\n")
		fmt.Fprintf(fOut, "}\n")
	}

	// genStructChainReflection
	{
		fOut, err := os.Create(filepath.Join(buildDir, "reflect_struct.inc"))
		if err != nil {
			panic(err)
		}

		defer fOut.Close()
		fmt.Fprintf(fOut, genString)

		fmt.Fprintf(fOut, "// NOLINTBEGIN\n")
		defer fmt.Fprintf(fOut, "// NOLINTEND\n")

		fmt.Fprintf(fOut, "[[nodiscard]] static inline size_t sizeOf(VkStructureType sType) noexcept {\n")
		fmt.Fprintf(fOut, "\tswitch(sType){\n")

		// get struct information
		for _, k := range typeNames {
			if sType, ok := sTypes[strings.ToUpper(k)]; ok {
				if blacklist[k] {
					// fmt.Println("BlackListed:", k)
					continue
				}

				fmt.Fprintf(fOut, "\t\tcase %s:\n", sType)
				fmt.Fprintf(fOut, "\t\t\treturn sizeof(%s);\n", k)
			}
		}

		fmt.Fprintf(fOut, "\t};\n")
		fmt.Fprintf(fOut, "\treturn 0;\n")
		fmt.Fprintf(fOut, "}\n")
	}
}

func genExtensionReflection(srcDir, buildDir string, data vkspec.Data, vkapi uint64) {
	type dependency struct {
		promotion uint64
		instance  []string
		device    []string
	}
	dependencies := map[string]dependency{}
	isPromoted := func(e vkspec.Extension) bool {
		promoted := e.Promoted
		for promoted != "" && data.Extensions[promoted].Promoted != "" && !strings.HasPrefix(promoted, "VK_VERSION_") {
			promoted = data.Extensions[promoted].Promoted
		}
		if vkVersion, ok := strings.CutPrefix(promoted, "VK_VERSION_"); e.Valid && ok {
			versionPair := strings.Split(vkVersion, "_")
			major, err := strconv.ParseUint(versionPair[0], 10, 0)
			if err != nil {
				panic(err)
			}
			minor, err := strconv.ParseUint(versionPair[1], 10, 0)
			if err != nil {
				panic(err)
			}

			if vkapi >= (major<<22)|(minor<<12) {
				return true
			}
			d := dependencies[e.Name]
			d.promotion = (major << 22) | (minor << 12)
			dependencies[e.Name] = d
		} else if e.Valid {
			d := dependencies[e.Name]
			dependencies[e.Name] = d
		}
		return false
	}
	for k, e := range data.Extensions {
		if e.Valid && !isPromoted(e) {
			for _, d := range e.Depends {
				if strings.HasPrefix(d, "VK_VERSION_1_") || isPromoted(data.Extensions[d]) {
					continue
				}
				switch data.Extensions[d].Kind {
				case "instance":
					list := dependencies[k]
					list.instance = append(list.instance, d)
					dependencies[k] = list
				case "device":
					list := dependencies[k]
					list.device = append(list.device, d)
					dependencies[k] = list
				}
			}
		}
	}
	for k, e := range dependencies {
		for i := 0; i < len(e.device); i++ {
			d := data.Extensions[e.device[i]]
			for _, d := range d.Depends {
				if isPromoted(data.Extensions[d]) {
					continue
				}
				switch data.Extensions[d].Kind {
				case "instance":
					e.instance = append(e.instance, d)
				case "device":
					e.device = append(e.device, d)
				}
			}
		}
		slices.Sort(e.device)
		e.device = slices.Compact(e.device)
		for i := 0; i < len(e.instance); i++ {
			d := data.Extensions[e.instance[i]]
			for _, d := range d.Depends {
				if isPromoted(data.Extensions[d]) {
					continue
				}
				switch data.Extensions[d].Kind {
				case "instance":
					e.instance = append(e.instance, d)
				case "device":
					panic("Instance extensions should not depend on device extensions")
				}
			}
		}
		slices.Sort(e.instance)
		e.instance = slices.Compact(e.instance)
		dependencies[k] = e
	}

	{
		fOut, err := os.Create(filepath.Join(buildDir, "reflect_extension.inc"))
		if err != nil {
			panic(err)
		}

		defer fOut.Close()
		fmt.Fprintf(fOut, genString)

		fmt.Fprintf(fOut, "// NOLINTBEGIN\n")
		defer fmt.Fprintf(fOut, "// NOLINTEND\n")

		fmt.Fprintf(fOut, "namespace internal {\n")
		for _, k := range slices.Sorted(maps.Keys(dependencies)) {
			e := dependencies[k]
			fmt.Fprintf(fOut, "static constexpr ::vkm::vk::reflect::internal::extensionInfoImpl<%d, %d> extension_%s {\n",
				len(e.instance), len(e.device), k)
			fmt.Fprintf(fOut, "\t%q, ", k)
			switch data.Extensions[k].Kind {
			case "instance":
				fmt.Fprintf(fOut, "::vkm::vk::reflect::extensionInfo::kind::instance, ")
			case "device":
				fmt.Fprintf(fOut, "::vkm::vk::reflect::extensionInfo::kind::device, ")
			default:
				panic(fmt.Sprintf("unexpected extension type: %s", data.Extensions[k].Kind))
			}
			fmt.Fprintf(fOut, "%d,\n", dependencies[k].promotion)
			fmt.Fprintf(fOut, "\t{\n")
			for _, d := range e.instance {
				fmt.Fprintf(fOut, "\t\t%q,\n", d)
			}
			fmt.Fprintf(fOut, "\t},\n")
			fmt.Fprintf(fOut, "\t{\n")
			for _, d := range e.device {
				fmt.Fprintf(fOut, "\t\t%q,\n", d)
			}
			fmt.Fprintf(fOut, "\t},\n")
			fmt.Fprintf(fOut, "};\n")
		}
		fmt.Fprintf(fOut, "} // vkm::vk::reflect::internal\n")

		{
			fmt.Fprintf(fOut, "[[nodiscard]] static inline const extensionInfo* extension(const char* target) noexcept {\n")

			// get struct information
			for _, k := range slices.Sorted(maps.Keys(dependencies)) {
				fmt.Fprintf(fOut, "\tif (strcmp(target, %q) == 0) {\n", k)
				fmt.Fprintf(fOut, "\t\treturn &internal::extension_%s;\n", k)
				fmt.Fprintf(fOut, "\t}\n")
			}

			fmt.Fprintf(fOut, "\treturn nullptr;\n")
			fmt.Fprintf(fOut, "}\n")
		}
	}
}

func genConstReflection(srcDir, buildDir string, data vkspec.Data) {
	types := data.Types
	imageUsageList := map[string]struct{}{}
	for _, u := range types["VkImageUsageFlags"].Declaration {
		parts := strings.Split(u, " = ")
		unmangled := strings.TrimSpace(parts[0][strings.Index(parts[0], "VK_"):])
		imageUsageList[unmangled] = struct{}{}
	}
	imageUsageToFeature := map[string]string{}
	for _, f := range types["VkFormatFeatureFlags2"].Declaration {
		parts := strings.Split(f, " = ")
		unmangled := strings.TrimSpace(parts[0][strings.Index(parts[0], "VK_"):])
		u := "VK_IMAGE_USAGE_" + strings.ReplaceAll(strings.TrimPrefix(unmangled, "VK_FORMAT_FEATURE_2_"), "_IMAGE_", "_")
		if _, ok := imageUsageList[u]; ok {
			imageUsageToFeature[u] = unmangled
		}
	}

	fOut, err := os.Create(filepath.Join(buildDir, "reflect_const.inc"))
	if err != nil {
		panic(err)
	}
	defer fOut.Close()

	fmt.Fprintf(fOut, genString)

	fmt.Fprintf(fOut, "// NOLINTBEGIN\n")
	defer fmt.Fprintf(fOut, "// NOLINTEND\n")

	// mapVkImageUsageFlagsToVkFormatFeatureFlags2
	{
		fmt.Fprintf(fOut, "[[nodiscard]] inline static VkFormatFeatureFlags2 mapVkImageUsageFlagsToVkFormatFeatureFlags2(VkImageUsageFlags usage) noexcept {\n")
		fmt.Fprintf(fOut, "\tVkFormatFeatureFlags2 features = 0;\n")

		for u, f := range imageUsageToFeature {
			fmt.Fprintf(fOut, "\tif (vkm::std::cmpBitFlagsContains(usage, %s)) {\n", u)
			fmt.Fprintf(fOut, "\t\tfeatures |= %s;\n", f)
			fmt.Fprintf(fOut, "\t}\n")
		}

		fmt.Fprintf(fOut, "\treturn features;\n")
		fmt.Fprintf(fOut, "}\n")
	}

	toString := func(t vkspec.Type) {
		process := func(line string) (string, string) {
			parts := strings.Split(line, " = ")
			identifier := parts[0][strings.Index(line, "VK_")+3:]
			value := parts[1]
			if strings.HasPrefix(value, "VK_") {
				return "", ""
			}
			return identifier, value
		}
		fmt.Fprintf(fOut, "[[nodiscard]] inline static vkm::std::string<char> toString(%s val) noexcept {\n", t.Name)
		fmt.Fprintf(fOut, "\tswitch (val) {\n")

		values := map[string]struct{}{}
		for _, f := range t.Declaration {
			id, value := process(f)
			if !strings.Contains(id, "MAX_ENUM") {
				if _, seen := values[value]; (id != "") && (value != "") && (!seen) {
					values[value] = struct{}{}
					fmt.Fprintf(fOut, "\t\tcase %s:\n\t\t\treturn %q;\n", value, id)
				}
			} else {
				fmt.Fprintf(fOut, "\t\tcase %s:\n\t\t\tbreak;\n", value)
			}
		}

		fmt.Fprintf(fOut, "\t}\n")
		fmt.Fprintf(fOut, "\treturn (vkm::std::stringbuilder<char>() << \"Unknown Value: \" << val).str();\n")
		fmt.Fprintf(fOut, "}\n")
	}
	toString(types["VkObjectType"])
	toString(types["VkResult"])
	toString(types["VkPresentModeKHR"])
	toString(types["VkFormat"])
	toString(types["VkColorSpaceKHR"])
}
